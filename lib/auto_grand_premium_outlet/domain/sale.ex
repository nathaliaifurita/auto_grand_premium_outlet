defmodule AutoGrandPremiumOutlet.Domain.Sale do
  @moduledoc """
  Domain entity representing a vehicle sale.
  """

  @enforce_keys [:vehicle_id, :buyer_cpf, :inserted_at]

  defstruct [
    :id,
    :vehicle_id,
    :buyer_cpf,
    :inserted_at,
    :updated_at,
    # :initiated | :completed | :cancelled
    status: :initiated
  ]

  @type status :: :initiated | :completed | :cancelled
  @type t :: %__MODULE__{
          id: any() | nil,
          vehicle_id: String.t(),
          buyer_cpf: String.t(),
          status: status(),
          inserted_at: DateTime.t(),
          updated_at: DateTime.t() | nil
        }

  ## -------- constructors --------

  @spec new(map()) ::
          {:ok, t()}
          | {:error, :invalid_state | :invalid_cpf}

  def new(%{status: _}), do: {:error, :invalid_state}

  @doc """
  Creates a new Sale entity.
  
  The `id` and `inserted_at` must be provided in attrs.
  These should be generated by the use case layer using infrastructure services.
  """
  def new(%{vehicle_id: vehicle_id, buyer_cpf: buyer_cpf} = attrs) do
    with :ok <- validate_vehicle_id(vehicle_id),
         :ok <- validate_cpf(buyer_cpf),
         :ok <- validate_id(attrs[:id]),
         :ok <- validate_inserted_at(attrs[:inserted_at]) do
      {:ok,
       %__MODULE__{
         id: attrs[:id],
         vehicle_id: vehicle_id,
         buyer_cpf: buyer_cpf,
         inserted_at: attrs[:inserted_at]
       }}
    end
  end

  ## -------- state transitions --------

  @doc """
  Completes a sale.
  The `updated_at` timestamp must be provided.
  """
  @spec complete(t(), DateTime.t()) :: {:ok, t()} | {:error, :invalid_transition}
  def complete(%__MODULE__{status: :initiated} = sale, updated_at) do
    {:ok,
     %{
       sale
       | status: :completed,
         updated_at: updated_at
     }}
  end

  def complete(%__MODULE__{status: status}, _updated_at) when status in [:completed, :cancelled],
    do: {:error, :invalid_transition}

  def complete(%__MODULE__{id: id}, _updated_at) when is_nil(id),
    do: {:error, :sale_not_found}

  @doc """
  Cancels a sale.
  The `updated_at` timestamp must be provided.
  """
  @spec cancel(t(), DateTime.t()) :: {:ok, t()} | {:error, :invalid_transition}
  def cancel(%__MODULE__{status: :initiated} = sale, updated_at) do
    {:ok,
     %{
       sale
       | status: :cancelled,
         updated_at: updated_at
     }}
  end

  def cancel(%__MODULE__{status: status}, _updated_at) when status in [:completed, :cancelled],
    do: {:error, :invalid_transition}

  def cancel(%__MODULE__{id: id}, _updated_at) when is_nil(id),
    do: {:error, :sale_not_found}

  ## -------- validations --------
  defp validate_id(nil), do: {:error, :id_required}
  defp validate_id(id) when is_binary(id) and byte_size(id) > 0, do: :ok
  defp validate_id(_), do: {:error, :invalid_id}

  defp validate_vehicle_id(id) when is_binary(id) and byte_size(id) > 0, do: :ok
  defp validate_vehicle_id(_), do: {:error, :vehicle_not_found}

  defp validate_cpf(cpf) when is_binary(cpf) do
    if Regex.match?(~r/^\d{11}$/, cpf), do: :ok, else: {:error, :invalid_cpf}
  end

  defp validate_cpf(_), do: {:error, :invalid_cpf}

  defp validate_inserted_at(nil), do: {:error, :inserted_at_required}
  defp validate_inserted_at(%DateTime{} = _dt), do: :ok
  defp validate_inserted_at(_), do: {:error, :invalid_inserted_at}
end
