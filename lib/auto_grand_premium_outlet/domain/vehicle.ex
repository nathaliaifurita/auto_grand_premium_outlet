defmodule AutoGrandPremiumOutlet.Domain.Vehicle do
  @moduledoc """
  Domain entity representing a vehicle.
  """

  @enforce_keys [:id, :brand, :model, :year, :price, :license_plate]

  defstruct [
    :id,
    :brand,
    :model,
    :year,
    :color,
    :price,
    :license_plate,
    :status,
    :inserted_at,
    :updated_at,
    :sold_at
  ]

  @type t :: %__MODULE__{
          id: any() | nil,
          brand: String.t(),
          model: String.t(),
          year: integer(),
          color: String.t() | nil,
          price: number(),
          license_plate: String.t(),
          status: atom() | nil,
          inserted_at: DateTime.t() | nil,
          updated_at: DateTime.t() | nil,
          sold_at: DateTime.t() | nil
        }

  @doc """
  Creates a new Vehicle entity.
  
  The `id` and `inserted_at` must be provided in attrs.
  These should be generated by the use case layer using infrastructure services.
  
  Parameters should be normalized before calling this function (keys as atoms, values with correct types).
  """
  @spec new(map()) ::
          {:ok, t()}
          | {:error, :invalid_year | :invalid_price | :invalid_license_plate | :invalid_id | :invalid_inserted_at}

  def new(attrs) when is_map(attrs) do
    with :ok <- validate_id(attrs[:id]),
         :ok <- maybe_validate_year(attrs[:year]),
         :ok <- maybe_validate_price(attrs[:price]),
         :ok <- maybe_validate_license_plate(attrs[:license_plate]),
         :ok <- validate_inserted_at(attrs[:inserted_at]) do
      {:ok,
       %__MODULE__{
         id: attrs[:id],
         brand: attrs[:brand],
         model: attrs[:model],
         year: attrs[:year],
         color: attrs[:color],
         price: attrs[:price],
         license_plate: attrs[:license_plate],
         status: Map.get(attrs, :status, :available),
         inserted_at: attrs[:inserted_at],
         updated_at: nil,
         sold_at: nil
       }}
    end
  end

  def new(_), do: {:error, :persistence_error}

  ## -------- helpers --------

  @spec available?(t()) :: boolean()
  def available?(%__MODULE__{status: :sold}), do: false
  def available?(_), do: true

  @doc """
  Marks a vehicle as sold.
  The `sold_at` timestamp must be provided.
  """
  @spec sell(t(), DateTime.t()) :: {:ok, t()} | {:error, :vehicle_already_sold}
  def sell(%__MODULE__{status: :sold}, _sold_at),
    do: {:error, :vehicle_already_sold}

  def sell(%__MODULE__{} = vehicle, sold_at) do
    {:ok,
     %{
       vehicle
       | status: :sold,
         sold_at: sold_at
     }}
  end

  @doc """
  Updates a vehicle with the provided attributes.
  
  Parameters should be normalized before calling this function (keys as atoms).
  The `updated_at` timestamp must be provided if any field is actually updated.
  """
  def update(%__MODULE__{} = vehicle, attrs, updated_at \\ nil) do
    with :ok <- maybe_validate_year(attrs[:year]),
         :ok <- maybe_validate_price(attrs[:price]),
         :ok <- maybe_validate_license_plate(attrs[:license_plate]) do
      updated_vehicle =
        Enum.reduce(attrs, vehicle, fn
          {:year, value}, acc -> %{acc | year: value}
          {:brand, value}, acc -> %{acc | brand: value}
          {:model, value}, acc -> %{acc | model: value}
          {:color, value}, acc -> %{acc | color: value}
          {:price, value}, acc -> %{acc | price: value}
          {:license_plate, value}, acc -> %{acc | license_plate: value}
          _, acc -> acc
        end)

      updated_vehicle =
        if updated_vehicle == vehicle do
          vehicle
        else
          if updated_at do
            %{updated_vehicle | updated_at: updated_at}
          else
            {:error, :updated_at_required}
          end
        end

      case updated_vehicle do
        {:error, _} = error -> error
        _ -> {:ok, updated_vehicle}
      end
    end
  end

  ## -------- validations --------
  defp validate_id(nil), do: {:error, :id_required}
  defp validate_id(id) when is_binary(id) and byte_size(id) > 0, do: :ok
  defp validate_id(_), do: {:error, :invalid_id}

  defp maybe_validate_year(nil), do: :ok
  defp maybe_validate_year(year) when is_integer(year) and year >= 1886, do: :ok
  defp maybe_validate_year(_), do: {:error, :invalid_year}

  defp maybe_validate_price(nil), do: :ok
  defp maybe_validate_price(price) when is_number(price) and price > 0, do: :ok
  defp maybe_validate_price(_), do: {:error, :invalid_price}

  defp maybe_validate_license_plate(nil), do: :ok

  defp maybe_validate_license_plate(lp) when is_binary(lp) do
    if Regex.match?(~r/^[A-Z]{3}[0-9][A-Z0-9][0-9]{2}$/, lp),
      do: :ok,
      else: {:error, :invalid_license_plate}
  end

  defp maybe_validate_license_plate(_), do: {:error, :invalid_license_plate}

  defp validate_inserted_at(nil), do: {:error, :inserted_at_required}
  defp validate_inserted_at(%DateTime{} = _dt), do: :ok
  defp validate_inserted_at(_), do: {:error, :invalid_inserted_at}
end
