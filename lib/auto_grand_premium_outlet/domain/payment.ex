defmodule AutoGrandPremiumOutlet.Domain.Payment do
  @moduledoc """
  Domain entity representing a payment for a sale.
  """

  @enforce_keys [:payment_code, :amount, :sale_id, :inserted_at]

  defstruct [
    :id,
    :payment_code,
    :amount,
    :sale_id,
    :inserted_at,
    :updated_at,
    # defaults ALWAYS last
    payment_status: :in_process
  ]

  @type payment_status :: :paid | :cancelled | :in_process
  @type t :: %__MODULE__{
          id: String.t(),
          payment_code: String.t(),
          amount: number(),
          sale_id: String.t(),
          payment_status: payment_status(),
          inserted_at: DateTime.t(),
          updated_at: DateTime.t() | nil
        }

  ## -------- constructors --------

  @doc """
  Creates a new Payment entity.

  The `id`, `payment_code`, and `inserted_at` must be provided in attrs.
  These should be generated by the use case layer using infrastructure services.
  """
  def new(attrs) do
    with :ok <- validate_sale_id(attrs.sale_id),
         :ok <- validate_amount(attrs.amount),
         :ok <- validate_id(attrs[:id]),
         :ok <- validate_payment_code(attrs[:payment_code]),
         :ok <- validate_inserted_at(attrs[:inserted_at]) do
      {:ok,
       %__MODULE__{
         id: attrs[:id],
         payment_code: attrs[:payment_code],
         amount: attrs.amount,
         sale_id: attrs.sale_id,
         inserted_at: attrs[:inserted_at]
       }}
    else
      {:error, reason} -> {:error, reason}
    end
  end

  ## -------- state transitions --------

  @doc """
  Marks a payment as paid.
  The `updated_at` timestamp must be provided.
  """
  def mark_as_paid(%__MODULE__{payment_status: :in_process} = payment, updated_at) do
    {:ok, %{payment | payment_status: :paid, updated_at: updated_at}}
  end

  def mark_as_paid(_, _updated_at),
    do: {:error, :invalid_transition}

  @doc """
  Cancels a payment.
  The `updated_at` timestamp must be provided.
  """
  def cancel(%__MODULE__{payment_status: :in_process} = payment, updated_at) do
    {:ok, %{payment | payment_status: :cancelled, updated_at: updated_at}}
  end

  def cancel(_, _updated_at),
    do: {:error, :invalid_transition}

  ## -------- validations --------
  defp validate_amount(amount)
       when is_number(amount) and amount > 0,
       do: :ok

  defp validate_amount(_),
    do: {:error, :invalid_amount}

  defp validate_sale_id(sale_id)
       when is_binary(sale_id) and byte_size(sale_id) > 0,
       do: :ok

  defp validate_sale_id(_),
    do: {:error, :invalid_sale_id}

  defp validate_id(nil), do: {:error, :id_required}
  defp validate_id(id) when is_binary(id) and byte_size(id) > 0, do: :ok
  defp validate_id(_), do: {:error, :invalid_id}

  defp validate_payment_code(nil), do: {:error, :payment_code_required}
  defp validate_payment_code(code) when is_binary(code) and byte_size(code) > 0, do: :ok
  defp validate_payment_code(_), do: {:error, :invalid_payment_code}

  defp validate_inserted_at(nil), do: {:error, :inserted_at_required}
  defp validate_inserted_at(%DateTime{} = _dt), do: :ok
  defp validate_inserted_at(_), do: {:error, :invalid_inserted_at}
end
